<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Category;
use App\Jobs\ProcessProjectAssets;
use App\Models\Project;
use App\Models\StorageSetting;
use App\Services\Storage\S3UsageService;
use Illuminate\Http\Request;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Illuminate\Support\Arr;

class ProjectController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        $projects = Project::with(['category', 'user'])
            ->latest()
            ->paginate(20);

        return view('admin.projects.index', compact('projects'));
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        $categories = Category::active()->get();
        $storageSettings = StorageSetting::getSettings();
        $s3Snapshot = app(S3UsageService::class)->snapshot();
        $s3Available = $storageSettings->hasValidS3Credentials() && !$storageSettings->avoid_s3;

        return view('admin.projects.create', compact('categories', 'storageSettings', 's3Snapshot', 's3Available'));
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        $settings = StorageSetting::getSettings();
        $snapshot = app(S3UsageService::class)->snapshot();
        $effectiveStorageType = $this->determineStorageType($request->input('storage_type'), $settings, $snapshot);

        $rules = [
            'title' => 'required|string|max:255',
            'description' => 'required|string',
            'short_description' => 'required|string|max:255',
            'type' => 'required|in:paid,free',
            'file_type' => 'required|in:image,video',
            'price' => 'nullable|numeric|min:0',
            'category_id' => 'required|exists:categories,id',
            'thumbnail' => 'nullable|image|max:2048',
            'image' => 'nullable|image|max:5120',
            'source_file' => 'nullable|file|mimes:zip,rar,7z,psd,ai|max:20480',
            'video' => 'nullable|mimes:mp4,avi,mov,wmv|max:51200',
            'video_link' => ['nullable', 'url', function ($attribute, $value, $fail) {
                if ($value && !preg_match('/^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)/', $value)) {
                    $fail('The video link must be a valid YouTube URL.');
                }
            }],
            'storage_type' => 'nullable|in:local,s3',
        ];

        if ($request->file_type === 'image') {
            $rules['thumbnail'] = 'required|image|max:2048';
        }

        $validated = $request->validate($rules);

        $projectData = Arr::except($validated, ['thumbnail', 'image', 'source_file', 'video']);
        $projectData['user_id'] = Auth::id();
        // Slug will be auto-generated by the model's boot method with uniqueness check
        // Set storage_type to local initially, will be updated by the job after files are processed
        $projectData['storage_type'] = 'local';

        $project = Project::create($projectData);

        [$payload, $previousPaths] = $this->prepareAssetPayload($request);

        if ($this->hasAssetPayload($payload)) {
            ProcessProjectAssets::dispatch(
                $project->id,
                $payload,
                $effectiveStorageType,
                $previousPaths,
                $project->storage_type
            );
        }

        return redirect()->route('admin.projects.index')
            ->with('success', 'Project created successfully and queued for asset processing');
    }

    /**
     * Display the specified resource.
     */
    public function show(Project $project)
    {
        $project->load(['category', 'user']);
        return view('admin.projects.show', compact('project'));
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Project $project)
    {
        $categories = Category::active()->get();
        $storageSettings = StorageSetting::getSettings();
        $s3Snapshot = app(S3UsageService::class)->snapshot();
        $s3Available = $storageSettings->hasValidS3Credentials() && !$storageSettings->avoid_s3;

        return view('admin.projects.edit', compact('project', 'categories', 'storageSettings', 's3Snapshot', 's3Available'));
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, Project $project)
    {
        $settings = StorageSetting::getSettings();
        $snapshot = app(S3UsageService::class)->snapshot();
        $requestedStorageType = $request->input('storage_type', $project->storage_type);
        $effectiveStorageType = $this->determineStorageType($requestedStorageType, $settings, $snapshot);

        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'required|string',
            'short_description' => 'required|string|max:255',
            'type' => 'required|in:paid,free',
            'file_type' => 'required|in:image,video',
            'price' => 'nullable|numeric|min:0',
            'category_id' => 'required|exists:categories,id',
            'thumbnail' => 'nullable|image|max:2048',
            'image' => 'nullable|image|max:5120',
            'source_file' => 'nullable|file|mimes:zip,rar,7z,psd,ai|max:20480',
            'video' => 'nullable|mimes:mp4,avi,mov,wmv|max:51200',
            'video_link' => ['nullable', 'url', function ($attribute, $value, $fail) {
                if ($value && !preg_match('/^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)/', $value)) {
                    $fail('The video link must be a valid YouTube URL.');
                }
            }],
            'storage_type' => 'nullable|in:local,s3',
        ]);

        $existingPaths = $project->only(['thumbnail', 'image', 'source_file', 'video']);
        $previousStorageType = $project->storage_type;
        $storageTypeChanged = $previousStorageType !== $effectiveStorageType;

        $projectData = Arr::except($validated, ['thumbnail', 'image', 'source_file', 'video']);
        // Slug will be auto-generated by the model's boot method if title changed
        $projectData['storage_type'] = $storageTypeChanged ? $previousStorageType : $effectiveStorageType;

        $project->update($projectData);

        [$payload, $previousPaths] = $this->prepareAssetPayload(
            $request,
            $project,
            $storageTypeChanged,
            $previousStorageType,
            $existingPaths
        );

        if ($this->hasAssetPayload($payload) || $storageTypeChanged) {
            ProcessProjectAssets::dispatch(
                $project->id,
                $payload,
                $effectiveStorageType,
                $previousPaths,
                $previousStorageType
            );
        }

        return redirect()->route('admin.projects.index')
            ->with('success', 'Project updated successfully and queued for asset processing');
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Project $project)
    {
        $paths = new \App\Services\Storage\Data\StoredAssetPaths(
            $project->thumbnail,
            $project->image,
            $project->source_file,
            $project->video
        );

        app(\App\Services\Storage\ProjectAssetManager::class)->delete(
            $project,
            $paths,
            $project->storage_type
        );

        $project->delete();

        return redirect()->route('admin.projects.index')
            ->with('success', 'Project deleted successfully');
    }

    /**
     * Toggle project active status
     */
    public function toggleStatus(Project $project)
    {
        $project->update(['is_active' => !$project->is_active]);

        return response()->json([
            'success' => true,
            'is_active' => $project->is_active
        ]);
    }

    protected function determineStorageType(?string $requested, StorageSetting $settings, ?array $snapshot = null): string
    {
        $requested = $requested ?: ($settings->default_storage_type ?? 'local');

        if ($settings->avoid_s3) {
            return 'local';
        }

        if ($requested === 's3' && !$settings->hasValidS3Credentials()) {
            return 'local';
        }

        if ($requested === 's3' && $snapshot && ($snapshot['force_local'] ?? false)) {
            return 'local';
        }

        return $requested === 's3' ? 's3' : 'local';
    }

    /**
     * @return array{0: array<string, mixed>, 1: array<string, string>}
     */
    protected function prepareAssetPayload(
        Request $request,
        ?Project $project = null,
        bool $includeExisting = false,
        ?string $existingStorageType = null,
        array $existingPaths = []
    ): array {
        $payload = [];
        $previousPaths = [];

        $map = [
            'thumbnail' => ['field' => 'thumbnail', 'temp_key' => 'thumbnail_temp_path', 'name_key' => 'thumbnail_original_name', 'type' => 'thumbnails'],
            'image' => ['field' => 'image', 'temp_key' => 'image_temp_path', 'name_key' => 'image_original_name', 'type' => 'images'],
            'source_file' => ['field' => 'source_file', 'temp_key' => 'source_temp_path', 'name_key' => 'source_original_name', 'type' => 'sources'],
            'video' => ['field' => 'video', 'temp_key' => 'video_temp_path', 'name_key' => 'video_original_name', 'type' => 'videos'],
        ];

        foreach ($map as $attribute => $config) {
            $field = $config['field'];
            $existingPath = $existingPaths[$attribute] ?? ($project ? $project->{$attribute} : null);

            if ($request->hasFile($field)) {
                [$tempPath, $originalName] = $this->storeTemporaryFile($request->file($field), $config['type']);
                $payload[$config['temp_key']] = $tempPath;
                $payload[$config['name_key']] = $originalName;

                if ($existingPath) {
                    $previousPaths[$attribute] = $existingPath;
                }
                continue;
            }

            if ($includeExisting && $existingPath) {
                $copied = $this->copyExistingAssetToTemp(
                    $existingStorageType ?? ($project?->storage_type ?? 'local'),
                    $existingPath,
                    $config['type']
                );

                if ($copied) {
                    [$tempPath, $originalName] = $copied;
                    $payload[$config['temp_key']] = $tempPath;
                    $payload[$config['name_key']] = $originalName;
                    $previousPaths[$attribute] = $existingPath;
                }
            }
        }

        return [$payload, $previousPaths];
    }

    protected function storeTemporaryFile(UploadedFile $file, string $type): array
    {
        $directory = $this->temporaryDirectory($type);
        Storage::disk('local')->makeDirectory($directory);
        $storedPath = $file->store($directory, 'local');

        return [$storedPath, $file->getClientOriginalName()];
    }

    protected function copyExistingAssetToTemp(string $storageType, string $path, string $type): ?array
    {
        $disk = $storageType === 's3' ? 'project_s3' : 'project_local';

        if (!Storage::disk($disk)->exists($path)) {
            return null;
        }

        $contents = Storage::disk($disk)->get($path);
        $directory = $this->temporaryDirectory($type);
        Storage::disk('local')->makeDirectory($directory);
        $filename = basename($path);
        $tempPath = "{$directory}/{$filename}";

        Storage::disk('local')->put($tempPath, $contents);

        return [$tempPath, $filename];
    }

    protected function temporaryDirectory(string $type): string
    {
        return 'temp/projects/' . now()->format('Ymd') . '/' . $type;
    }

    protected function hasAssetPayload(array $payload): bool
    {
        return collect($payload)
            ->filter(fn($value, $key) => str_ends_with($key, '_temp_path') && filled($value))
            ->isNotEmpty();
    }
}
